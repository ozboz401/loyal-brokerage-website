-- =====================================================
-- TMS Additional Schema - Remaining Modules
-- Accounting RPCs, Dashboard Analytics, Settings, Activity Logs
-- =====================================================

-- =====================================================
-- ACTIVITY LOGS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS activity_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id TEXT,
    user_email TEXT,
    action TEXT NOT NULL CHECK (action IN ('create', 'update', 'delete', 'view', 'login', 'export')),
    module TEXT NOT NULL CHECK (module IN ('load', 'customer', 'carrier', 'agent', 'crm', 'accounting', 'settings', 'dashboard')),
    record_id TEXT,
    details JSONB,
    ip_address TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for performance
CREATE INDEX IF NOT EXISTS idx_activity_logs_user ON activity_logs(user_email);
CREATE INDEX IF NOT EXISTS idx_activity_logs_module ON activity_logs(module);
CREATE INDEX IF NOT EXISTS idx_activity_logs_action ON activity_logs(action);
CREATE INDEX IF NOT EXISTS idx_activity_logs_created ON activity_logs(created_at DESC);

-- RLS for activity_logs (admin only)
ALTER TABLE activity_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admin can view all activity logs" ON activity_logs;
CREATE POLICY "Admin can view all activity logs" ON activity_logs
    FOR SELECT
    USING (auth.jwt() ->> 'email' = 'ozan@loyalbrokerage.com');

DROP POLICY IF EXISTS "System can insert activity logs" ON activity_logs;
CREATE POLICY "System can insert activity logs" ON activity_logs
    FOR INSERT
    WITH CHECK (true);

-- =====================================================
-- SETTINGS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS tms_settings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    key TEXT UNIQUE NOT NULL,
    value JSONB NOT NULL,
    category TEXT NOT NULL CHECK (category IN ('company', 'commission', 'preferences', 'system')),
    updated_by TEXT,
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS for settings (admin only)
ALTER TABLE tms_settings ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admin can manage settings" ON tms_settings;
CREATE POLICY "Admin can manage settings" ON tms_settings
    FOR ALL
    USING (auth.jwt() ->> 'email' = 'ozan@loyalbrokerage.com');

-- Insert default settings
INSERT INTO tms_settings (key, value, category) VALUES
('company_name', '{"value": "Loyal Brokerage"}', 'company'),
('company_mc', '{"value": ""}', 'company'),
('company_dot', '{"value": ""}', 'company'),
('company_address', '{"value": ""}', 'company'),
('default_commission_rate', '{"value": 10.0}', 'commission'),
('currency', '{"value": "USD"}', 'preferences'),
('timezone', '{"value": "America/New_York"}', 'preferences'),
('theme', '{"value": "dark"}', 'preferences')
ON CONFLICT (key) DO NOTHING;

-- =====================================================
-- DASHBOARD ANALYTICS RPC FUNCTIONS
-- =====================================================

-- Get total loads this month
CREATE OR REPLACE FUNCTION get_loads_this_month()
RETURNS TABLE (
    total_count BIGINT,
    total_revenue NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::BIGINT as total_count,
        COALESCE(SUM(rate), 0) as total_revenue
    FROM loads
    WHERE DATE_TRUNC('month', created_at) = DATE_TRUNC('month', CURRENT_DATE);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get outstanding receivables
CREATE OR REPLACE FUNCTION get_outstanding_receivables()
RETURNS TABLE (
    total_outstanding NUMERIC,
    count_pending BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COALESCE(SUM(amount), 0) as total_outstanding,
        COUNT(*)::BIGINT as count_pending
    FROM invoices
    WHERE status IN ('Pending', 'Sent', 'Overdue');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get aged receivables
CREATE OR REPLACE FUNCTION get_aged_receivables()
RETURNS TABLE (
    bucket TEXT,
    amount NUMERIC,
    count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        CASE 
            WHEN CURRENT_DATE - date_sent <= 30 THEN '0-30 days'
            WHEN CURRENT_DATE - date_sent <= 60 THEN '31-60 days'
            WHEN CURRENT_DATE - date_sent <= 90 THEN '61-90 days'
            ELSE '90+ days'
        END as bucket,
        SUM(amount) as amount,
        COUNT(*)::BIGINT as count
    FROM invoices
    WHERE status IN ('Pending', 'Sent', 'Overdue')
    GROUP BY bucket
    ORDER BY 
        CASE bucket
            WHEN '0-30 days' THEN 1
            WHEN '31-60 days' THEN 2
            WHEN '61-90 days' THEN 3
            ELSE 4
        END;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get top customers by revenue
CREATE OR REPLACE FUNCTION get_top_customers(limit_count INT DEFAULT 5)
RETURNS TABLE (
    customer_id BIGINT,
    customer_name TEXT,
    total_revenue NUMERIC,
    load_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.id as customer_id,
        c.name as customer_name,
        COALESCE(SUM(l.rate), 0) as total_revenue,
        COUNT(l.id)::BIGINT as load_count
    FROM tms_customers c
    LEFT JOIN loads l ON c.id = l.customer_id
    GROUP BY c.id, c.name
    ORDER BY total_revenue DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get top carriers by volume
CREATE OR REPLACE FUNCTION get_top_carriers(limit_count INT DEFAULT 5)
RETURNS TABLE (
    carrier_id BIGINT,
    carrier_name TEXT,
    load_count BIGINT,
    total_cost NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.id as carrier_id,
        c.name as carrier_name,
        COUNT(l.id)::BIGINT as load_count,
        COALESCE(SUM(l.carrier_cost), 0) as total_cost
    FROM tms_carriers c
    LEFT JOIN loads l ON c.id = l.carrier_id
    GROUP BY c.id, c.name
    ORDER BY load_count DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get agent leaderboard
CREATE OR REPLACE FUNCTION get_agent_leaderboard()
RETURNS TABLE (
    agent_id BIGINT,
    agent_name TEXT,
    total_loads BIGINT,
    total_revenue NUMERIC,
    total_profit NUMERIC,
    avg_commission NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        a.id as agent_id,
        a.name as agent_name,
        COUNT(l.id)::BIGINT as total_loads,
        COALESCE(SUM(l.rate), 0) as total_revenue,
        COALESCE(SUM(l.rate - l.carrier_cost), 0) as total_profit,
        a.commission_rate as avg_commission
    FROM tms_agents a
    LEFT JOIN loads l ON a.id = l.agent_id
    WHERE a.status = 'Active'
    GROUP BY a.id, a.name, a.commission_rate
    ORDER BY total_revenue DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get weekly revenue (last 12 weeks)
CREATE OR REPLACE FUNCTION get_weekly_revenue(weeks_count INT DEFAULT 12)
RETURNS TABLE (
    week_start DATE,
    week_label TEXT,
    revenue NUMERIC,
    load_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    WITH week_series AS (
        SELECT 
            DATE_TRUNC('week', CURRENT_DATE - (n || ' weeks')::INTERVAL)::DATE as week_start
        FROM generate_series(0, weeks_count - 1) n
    )
    SELECT 
        ws.week_start,
        TO_CHAR(ws.week_start, 'Mon DD') as week_label,
        COALESCE(SUM(l.rate), 0) as revenue,
        COUNT(l.id)::BIGINT as load_count
    FROM week_series ws
    LEFT JOIN loads l ON DATE_TRUNC('week', l.created_at)::DATE = ws.week_start
    GROUP BY ws.week_start
    ORDER BY ws.week_start;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get load status breakdown
CREATE OR REPLACE FUNCTION get_load_status_breakdown()
RETURNS TABLE (
    status TEXT,
    count BIGINT,
    percentage NUMERIC
) AS $$
DECLARE
    total_loads BIGINT;
BEGIN
    SELECT COUNT(*) INTO total_loads FROM loads;
    
    RETURN QUERY
    SELECT 
        l.status,
        COUNT(*)::BIGINT as count,
        CASE 
            WHEN total_loads > 0 THEN ROUND((COUNT(*)::NUMERIC / total_loads * 100), 2)
            ELSE 0
        END as percentage
    FROM loads l
    GROUP BY l.status
    ORDER BY count DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get carrier payables summary
CREATE OR REPLACE FUNCTION get_carrier_payables()
RETURNS TABLE (
    carrier_id BIGINT,
    carrier_name TEXT,
    total_owed NUMERIC,
    oldest_unpaid_date DATE,
    unpaid_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.id as carrier_id,
        c.name as carrier_name,
        COALESCE(SUM(l.carrier_cost), 0) as total_owed,
        MIN(l.created_at::DATE) as oldest_unpaid_date,
        COUNT(*)::BIGINT as unpaid_count
    FROM tms_carriers c
    INNER JOIN loads l ON c.id = l.carrier_id
    WHERE l.status IN ('Delivered', 'Completed')
    GROUP BY c.id, c.name
    HAVING SUM(l.carrier_cost) > 0
    ORDER BY total_owed DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- ACCOUNTING HELPER FUNCTIONS
-- =====================================================

-- Auto-update invoice status based on due date
CREATE OR REPLACE FUNCTION update_invoice_status()
RETURNS VOID AS $$
BEGIN
    UPDATE invoices
    SET status = 'Overdue'
    WHERE status IN ('Pending', 'Sent')
    AND due_date < CURRENT_DATE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Calculate total receivables by customer
CREATE OR REPLACE FUNCTION get_customer_receivables(customer_id_param BIGINT)
RETURNS TABLE (
    total_invoiced NUMERIC,
    total_paid NUMERIC,
    total_outstanding NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COALESCE(SUM(amount), 0) as total_invoiced,
        COALESCE(SUM(CASE WHEN status = 'Paid' THEN amount ELSE 0 END), 0) as total_paid,
        COALESCE(SUM(CASE WHEN status != 'Paid' THEN amount ELSE 0 END), 0) as total_outstanding
    FROM invoices
    WHERE customer_id = customer_id_param;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
